{"ast":null,"code":"import _slicedToArray from \"C:/Users/Max/Desktop/project1.0.0-main/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"C:/Users/Max/Desktop/project1.0.0-main/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Max/Desktop/project1.0.0-main/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/Max/Desktop/project1.0.0-main/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/Max/Desktop/project1.0.0-main/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Max/Desktop/project1.0.0-main/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.object.get-own-property-names.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.reflect.to-string-tag.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.reflect.set.js\";\nimport \"core-js/modules/es.reflect.delete-property.js\";\nimport \"core-js/modules/es.reflect.has.js\";\nimport \"core-js/modules/es.reflect.own-keys.js\";\nimport \"core-js/modules/es.reflect.get-prototype-of.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.object.is-extensible.js\";\nimport { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg) {\n  var _console;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  (_console = console).warn.apply(_console, [\"[Vue warn] \".concat(msg)].concat(args));\n}\n\nvar activeEffectScope;\n\nvar EffectScope = /*#__PURE__*/function () {\n  function EffectScope() {\n    var detached = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    _classCallCheck(this, EffectScope);\n\n    /**\n     * @internal\n     */\n    this.active = true;\n    /**\n     * @internal\n     */\n\n    this.effects = [];\n    /**\n     * @internal\n     */\n\n    this.cleanups = [];\n\n    if (!detached && activeEffectScope) {\n      this.parent = activeEffectScope;\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n\n  _createClass(EffectScope, [{\n    key: \"run\",\n    value: function run(fn) {\n      if (this.active) {\n        var currentEffectScope = activeEffectScope;\n\n        try {\n          activeEffectScope = this;\n          return fn();\n        } finally {\n          activeEffectScope = currentEffectScope;\n        }\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn(\"cannot run an inactive effect scope.\");\n      }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n\n  }, {\n    key: \"on\",\n    value: function on() {\n      activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n\n  }, {\n    key: \"off\",\n    value: function off() {\n      activeEffectScope = this.parent;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop(fromParent) {\n      if (this.active) {\n        var i, l;\n\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].stop();\n        }\n\n        for (i = 0, l = this.cleanups.length; i < l; i++) {\n          this.cleanups[i]();\n        }\n\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].stop(true);\n          }\n        } // nested scope, dereference from parent to avoid memory leaks\n\n\n        if (this.parent && !fromParent) {\n          // optimized O(1) removal\n          var last = this.parent.scopes.pop();\n\n          if (last && last !== this) {\n            this.parent.scopes[this.index] = last;\n            last.index = this.index;\n          }\n        }\n\n        this.active = false;\n      }\n    }\n  }]);\n\n  return EffectScope;\n}();\n\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\n\nfunction recordEffectScope(effect) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : activeEffectScope;\n\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\n\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\n\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\"onScopeDispose() is called when there is no active effect scope\" + \" to be associated with.\");\n  }\n}\n\nvar createDep = function createDep(effects) {\n  var dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\n\nvar wasTracked = function wasTracked(dep) {\n  return (dep.w & trackOpBit) > 0;\n};\n\nvar newTracked = function newTracked(dep) {\n  return (dep.n & trackOpBit) > 0;\n};\n\nvar initDepMarkers = function initDepMarkers(_ref) {\n  var deps = _ref.deps;\n\n  if (deps.length) {\n    for (var i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit; // set was tracked\n    }\n  }\n};\n\nvar finalizeDepMarkers = function finalizeDepMarkers(effect) {\n  var deps = effect.deps;\n\n  if (deps.length) {\n    var ptr = 0;\n\n    for (var i = 0; i < deps.length; i++) {\n      var dep = deps[i];\n\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      } // clear bits\n\n\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n\n    deps.length = ptr;\n  }\n};\n\nvar targetMap = new WeakMap(); // The number of effects currently being tracked recursively.\n\nvar effectTrackDepth = 0;\nvar trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\n\nvar maxMarkerBits = 30;\nvar activeEffect;\nvar ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'iterate' : '');\nvar MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'Map key iterate' : '');\n\nvar ReactiveEffect = /*#__PURE__*/function () {\n  function ReactiveEffect(fn) {\n    var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var scope = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ReactiveEffect);\n\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = undefined;\n    recordEffectScope(this, scope);\n  }\n\n  _createClass(ReactiveEffect, [{\n    key: \"run\",\n    value: function run() {\n      if (!this.active) {\n        return this.fn();\n      }\n\n      var parent = activeEffect;\n      var lastShouldTrack = shouldTrack;\n\n      while (parent) {\n        if (parent === this) {\n          return;\n        }\n\n        parent = parent.parent;\n      }\n\n      try {\n        this.parent = activeEffect;\n        activeEffect = this;\n        shouldTrack = true;\n        trackOpBit = 1 << ++effectTrackDepth;\n\n        if (effectTrackDepth <= maxMarkerBits) {\n          initDepMarkers(this);\n        } else {\n          cleanupEffect(this);\n        }\n\n        return this.fn();\n      } finally {\n        if (effectTrackDepth <= maxMarkerBits) {\n          finalizeDepMarkers(this);\n        }\n\n        trackOpBit = 1 << --effectTrackDepth;\n        activeEffect = this.parent;\n        shouldTrack = lastShouldTrack;\n        this.parent = undefined;\n\n        if (this.deferStop) {\n          this.stop();\n        }\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // stopped while running itself - defer the cleanup\n      if (activeEffect === this) {\n        this.deferStop = true;\n      } else if (this.active) {\n        cleanupEffect(this);\n\n        if (this.onStop) {\n          this.onStop();\n        }\n\n        this.active = false;\n      }\n    }\n  }]);\n\n  return ReactiveEffect;\n}();\n\nfunction cleanupEffect(effect) {\n  var deps = effect.deps;\n\n  if (deps.length) {\n    for (var i = 0; i < deps.length; i++) {\n      deps[i].delete(effect);\n    }\n\n    deps.length = 0;\n  }\n}\n\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n\n  var _effect = new ReactiveEffect(fn);\n\n  if (options) {\n    extend(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n\n  var runner = _effect.run.bind(_effect);\n\n  runner.effect = _effect;\n  return runner;\n}\n\nfunction stop(runner) {\n  runner.effect.stop();\n}\n\nvar shouldTrack = true;\nvar trackStack = [];\n\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\n\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\n\nfunction resetTracking() {\n  var last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\n\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    var depsMap = targetMap.get(target);\n\n    if (!depsMap) {\n      targetMap.set(target, depsMap = new Map());\n    }\n\n    var dep = depsMap.get(key);\n\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n\n    var eventInfo = process.env.NODE_ENV !== 'production' ? {\n      effect: activeEffect,\n      target: target,\n      type: type,\n      key: key\n    } : undefined;\n    trackEffects(dep, eventInfo);\n  }\n}\n\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  var shouldTrack = false;\n\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit; // set newly tracked\n\n      shouldTrack = !wasTracked(dep);\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect);\n  }\n\n  if (shouldTrack) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n\n    if (process.env.NODE_ENV !== 'production' && activeEffect.onTrack) {\n      activeEffect.onTrack(Object.assign({\n        effect: activeEffect\n      }, debuggerEventExtraInfo));\n    }\n  }\n}\n\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  var depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    // never been tracked\n    return;\n  }\n\n  var deps = [];\n\n  if (type === \"clear\"\n  /* CLEAR */\n  ) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = _toConsumableArray(depsMap.values());\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach(function (dep, key) {\n      if (key === 'length' || key >= newValue) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    } // also run for iteration key on ADD | DELETE | Map.SET\n\n\n    switch (type) {\n      case \"add\"\n      /* ADD */\n      :\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'));\n        }\n\n        break;\n\n      case \"delete\"\n      /* DELETE */\n      :\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n\n        break;\n\n      case \"set\"\n      /* SET */\n      :\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n\n        break;\n    }\n  }\n\n  var eventInfo = process.env.NODE_ENV !== 'production' ? {\n    target: target,\n    type: type,\n    key: key,\n    newValue: newValue,\n    oldValue: oldValue,\n    oldTarget: oldTarget\n  } : undefined;\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (process.env.NODE_ENV !== 'production') {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    var effects = [];\n\n    var _iterator = _createForOfIteratorHelper(deps),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var dep = _step.value;\n\n        if (dep) {\n          effects.push.apply(effects, _toConsumableArray(dep));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\n\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  // spread into array for stabilization\n  var _iterator2 = _createForOfIteratorHelper(isArray(dep) ? dep : _toConsumableArray(dep)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _effect2 = _step2.value;\n\n      if (_effect2 !== activeEffect || _effect2.allowRecurse) {\n        if (process.env.NODE_ENV !== 'production' && _effect2.onTrigger) {\n          _effect2.onTrigger(extend({\n            effect: _effect2\n          }, debuggerEventExtraInfo));\n        }\n\n        if (_effect2.scheduler) {\n          _effect2.scheduler();\n        } else {\n          _effect2.run();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nvar isNonTrackableKeys = /*#__PURE__*/makeMap(\"__proto__,__v_isRef,__isVue\");\nvar builtInSymbols = new Set( /*#__PURE__*/Object.getOwnPropertyNames(Symbol).map(function (key) {\n  return Symbol[key];\n}).filter(isSymbol));\nvar get = /*#__PURE__*/createGetter();\nvar shallowGet = /*#__PURE__*/createGetter(false, true);\nvar readonlyGet = /*#__PURE__*/createGetter(true);\nvar shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);\nvar arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();\n\nfunction createArrayInstrumentations() {\n  var instrumentations = {};\n  ['includes', 'indexOf', 'lastIndexOf'].forEach(function (key) {\n    instrumentations[key] = function () {\n      var arr = toRaw(this);\n\n      for (var i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\"\n        /* GET */\n        , i + '');\n      } // we run the method using the original args first (which may be reactive)\n\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var res = arr[key].apply(arr, args);\n\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key].apply(arr, _toConsumableArray(args.map(toRaw)));\n      } else {\n        return res;\n      }\n    };\n  });\n  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function (key) {\n    instrumentations[key] = function () {\n      pauseTracking();\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      var res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\n\nfunction createGetter() {\n  var isReadonly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var shallow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return function get(target, key, receiver) {\n    if (key === \"__v_isReactive\"\n    /* IS_REACTIVE */\n    ) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\"\n    /* IS_READONLY */\n    ) {\n      return isReadonly;\n    } else if (key === \"__v_isShallow\"\n    /* IS_SHALLOW */\n    ) {\n      return shallow;\n    } else if (key === \"__v_raw\"\n    /* RAW */\n    && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n\n    var targetIsArray = isArray(target);\n\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n\n    var res = Reflect.get(target, key, receiver);\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n\n    if (!isReadonly) {\n      track(target, \"get\"\n      /* GET */\n      , key);\n    }\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      var shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n      return shouldUnwrap ? res.value : res;\n    }\n\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  };\n}\n\nvar set = /*#__PURE__*/createSetter();\nvar shallowSet = /*#__PURE__*/createSetter(true);\n\nfunction createSetter() {\n  var shallow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return function set(target, key, value, receiver) {\n    var oldValue = target[key];\n\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n\n    if (!shallow && !isReadonly(value)) {\n      if (!isShallow(value)) {\n        value = toRaw(value);\n        oldValue = toRaw(oldValue);\n      }\n\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n\n    var hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    var result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original\n\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\"\n        /* ADD */\n        , key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\"\n        /* SET */\n        , key, value, oldValue);\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction deleteProperty(target, key) {\n  var hadKey = hasOwn(target, key);\n  var oldValue = target[key];\n  var result = Reflect.deleteProperty(target, key);\n\n  if (result && hadKey) {\n    trigger(target, \"delete\"\n    /* DELETE */\n    , key, undefined, oldValue);\n  }\n\n  return result;\n}\n\nfunction has(target, key) {\n  var result = Reflect.has(target, key);\n\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\"\n    /* HAS */\n    , key);\n  }\n\n  return result;\n}\n\nfunction ownKeys(target) {\n  track(target, \"iterate\"\n  /* ITERATE */\n  , isArray(target) ? 'length' : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\n\nvar mutableHandlers = {\n  get: get,\n  set: set,\n  deleteProperty: deleteProperty,\n  has: has,\n  ownKeys: ownKeys\n};\nvar readonlyHandlers = {\n  get: readonlyGet,\n  set: function set(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Set operation on key \\\"\".concat(String(key), \"\\\" failed: target is readonly.\"), target);\n    }\n\n    return true;\n  },\n  deleteProperty: function deleteProperty(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Delete operation on key \\\"\".concat(String(key), \"\\\" failed: target is readonly.\"), target);\n    }\n\n    return true;\n  }\n};\nvar shallowReactiveHandlers = /*#__PURE__*/extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n}); // Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\n\nvar shallowReadonlyHandlers = /*#__PURE__*/extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\n\nvar toShallow = function toShallow(value) {\n  return value;\n};\n\nvar getProto = function getProto(v) {\n  return Reflect.getPrototypeOf(v);\n};\n\nfunction get$1(target, key) {\n  var isReadonly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isShallow = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = target[\"__v_raw\"\n  /* RAW */\n  ];\n  var rawTarget = toRaw(target);\n  var rawKey = toRaw(key);\n\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"get\"\n    /* GET */\n    , key);\n  }\n\n  !isReadonly && track(rawTarget, \"get\"\n  /* GET */\n  , rawKey);\n\n  var _getProto = getProto(rawTarget),\n      has = _getProto.has;\n\n  var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key);\n  }\n}\n\nfunction has$1(key) {\n  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var target = this[\"__v_raw\"\n  /* RAW */\n  ];\n  var rawTarget = toRaw(target);\n  var rawKey = toRaw(key);\n\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"has\"\n    /* HAS */\n    , key);\n  }\n\n  !isReadonly && track(rawTarget, \"has\"\n  /* HAS */\n  , rawKey);\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\n\nfunction size(target) {\n  var isReadonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  target = target[\"__v_raw\"\n  /* RAW */\n  ];\n  !isReadonly && track(toRaw(target), \"iterate\"\n  /* ITERATE */\n  , ITERATE_KEY);\n  return Reflect.get(target, 'size', target);\n}\n\nfunction add(value) {\n  value = toRaw(value);\n  var target = toRaw(this);\n  var proto = getProto(target);\n  var hadKey = proto.has.call(target, value);\n\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\"\n    /* ADD */\n    , value, value);\n  }\n\n  return this;\n}\n\nfunction set$1(key, value) {\n  value = toRaw(value);\n  var target = toRaw(this);\n\n  var _getProto2 = getProto(target),\n      has = _getProto2.has,\n      get = _getProto2.get;\n\n  var hadKey = has.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n\n  var oldValue = get.call(target, key);\n  target.set(key, value);\n\n  if (!hadKey) {\n    trigger(target, \"add\"\n    /* ADD */\n    , key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\"\n    /* SET */\n    , key, value, oldValue);\n  }\n\n  return this;\n}\n\nfunction deleteEntry(key) {\n  var target = toRaw(this);\n\n  var _getProto3 = getProto(target),\n      has = _getProto3.has,\n      get = _getProto3.get;\n\n  var hadKey = has.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n\n  var oldValue = get ? get.call(target, key) : undefined; // forward the operation before queueing reactions\n\n  var result = target.delete(key);\n\n  if (hadKey) {\n    trigger(target, \"delete\"\n    /* DELETE */\n    , key, undefined, oldValue);\n  }\n\n  return result;\n}\n\nfunction clear() {\n  var target = toRaw(this);\n  var hadItems = target.size !== 0;\n  var oldTarget = process.env.NODE_ENV !== 'production' ? isMap(target) ? new Map(target) : new Set(target) : undefined; // forward the operation before queueing reactions\n\n  var result = target.clear();\n\n  if (hadItems) {\n    trigger(target, \"clear\"\n    /* CLEAR */\n    , undefined, undefined, oldTarget);\n  }\n\n  return result;\n}\n\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    var observed = this;\n    var target = observed[\"__v_raw\"\n    /* RAW */\n    ];\n    var rawTarget = toRaw(target);\n    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\"\n    /* ITERATE */\n    , ITERATE_KEY);\n    return target.forEach(function (value, key) {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\n\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function () {\n    var target = this[\"__v_raw\"\n    /* RAW */\n    ];\n    var rawTarget = toRaw(target);\n    var targetIsMap = isMap(rawTarget);\n    var isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;\n    var isKeyOnly = method === 'keys' && targetIsMap;\n    var innerIterator = target[method].apply(target, arguments);\n    var wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\"\n    /* ITERATE */\n    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n\n    return _defineProperty({\n      // iterator protocol\n      next: function next() {\n        var _innerIterator$next = innerIterator.next(),\n            value = _innerIterator$next.value,\n            done = _innerIterator$next.done;\n\n        return done ? {\n          value: value,\n          done: done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done: done\n        };\n      }\n    }, Symbol.iterator, function () {\n      return this;\n    });\n  };\n}\n\nfunction createReadonlyMethod(type) {\n  return function () {\n    if (process.env.NODE_ENV !== 'production') {\n      var key = (arguments.length <= 0 ? undefined : arguments[0]) ? \"on key \\\"\".concat(arguments.length <= 0 ? undefined : arguments[0], \"\\\" \") : \"\";\n      console.warn(\"\".concat(capitalize(type), \" operation \").concat(key, \"failed: target is readonly.\"), toRaw(this));\n    }\n\n    return type === \"delete\"\n    /* DELETE */\n    ? false : this;\n  };\n}\n\nfunction createInstrumentations() {\n  var mutableInstrumentations = {\n    get: function get(key) {\n      return get$1(this, key);\n    },\n\n    get size() {\n      return size(this);\n    },\n\n    has: has$1,\n    add: add,\n    set: set$1,\n    delete: deleteEntry,\n    clear: clear,\n    forEach: createForEach(false, false)\n  };\n  var shallowInstrumentations = {\n    get: function get(key) {\n      return get$1(this, key, false, true);\n    },\n\n    get size() {\n      return size(this);\n    },\n\n    has: has$1,\n    add: add,\n    set: set$1,\n    delete: deleteEntry,\n    clear: clear,\n    forEach: createForEach(false, true)\n  };\n  var readonlyInstrumentations = {\n    get: function get(key) {\n      return get$1(this, key, true);\n    },\n\n    get size() {\n      return size(this, true);\n    },\n\n    has: function has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"\n    /* ADD */\n    ),\n    set: createReadonlyMethod(\"set\"\n    /* SET */\n    ),\n    delete: createReadonlyMethod(\"delete\"\n    /* DELETE */\n    ),\n    clear: createReadonlyMethod(\"clear\"\n    /* CLEAR */\n    ),\n    forEach: createForEach(true, false)\n  };\n  var shallowReadonlyInstrumentations = {\n    get: function get(key) {\n      return get$1(this, key, true, true);\n    },\n\n    get size() {\n      return size(this, true);\n    },\n\n    has: function has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"\n    /* ADD */\n    ),\n    set: createReadonlyMethod(\"set\"\n    /* SET */\n    ),\n    delete: createReadonlyMethod(\"delete\"\n    /* DELETE */\n    ),\n    clear: createReadonlyMethod(\"clear\"\n    /* CLEAR */\n    ),\n    forEach: createForEach(true, true)\n  };\n  var iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n  iteratorMethods.forEach(function (method) {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];\n}\n\nvar _createInstrumentatio = /* #__PURE__*/createInstrumentations(),\n    _createInstrumentatio2 = _slicedToArray(_createInstrumentatio, 4),\n    mutableInstrumentations = _createInstrumentatio2[0],\n    readonlyInstrumentations = _createInstrumentatio2[1],\n    shallowInstrumentations = _createInstrumentatio2[2],\n    shallowReadonlyInstrumentations = _createInstrumentatio2[3];\n\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  var instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return function (target, key, receiver) {\n    if (key === \"__v_isReactive\"\n    /* IS_REACTIVE */\n    ) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\"\n    /* IS_READONLY */\n    ) {\n      return isReadonly;\n    } else if (key === \"__v_raw\"\n    /* RAW */\n    ) {\n      return target;\n    }\n\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\n\nvar mutableCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, false)\n};\nvar shallowCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, true)\n};\nvar readonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, false)\n};\nvar shallowReadonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, true)\n};\n\nfunction checkIdentityKeys(target, has, key) {\n  var rawKey = toRaw(key);\n\n  if (rawKey !== key && has.call(target, rawKey)) {\n    var type = toRawType(target);\n    console.warn(\"Reactive \".concat(type, \" contains both the raw and reactive \") + \"versions of the same object\".concat(type === \"Map\" ? \" as keys\" : \"\", \", \") + \"which can lead to inconsistencies. \" + \"Avoid differentiating between the raw and reactive versions \" + \"of an object and only use the reactive version if possible.\");\n  }\n}\n\nvar reactiveMap = new WeakMap();\nvar shallowReactiveMap = new WeakMap();\nvar readonlyMap = new WeakMap();\nvar shallowReadonlyMap = new WeakMap();\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return 1\n      /* COMMON */\n      ;\n\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return 2\n      /* COLLECTION */\n      ;\n\n    default:\n      return 0\n      /* INVALID */\n      ;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\"\n  /* SKIP */\n  ] || !Object.isExtensible(value) ? 0\n  /* INVALID */\n  : targetTypeMap(toRawType(value));\n}\n\nfunction reactive(target) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target;\n  }\n\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\n\n\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\n\n\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\n\n\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\n\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\"value cannot be made reactive: \".concat(String(target)));\n    }\n\n    return target;\n  } // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n\n\n  if (target[\"__v_raw\"\n  /* RAW */\n  ] && !(isReadonly && target[\"__v_isReactive\"\n  /* IS_REACTIVE */\n  ])) {\n    return target;\n  } // target already has corresponding Proxy\n\n\n  var existingProxy = proxyMap.get(target);\n\n  if (existingProxy) {\n    return existingProxy;\n  } // only a whitelist of value types can be observed.\n\n\n  var targetType = getTargetType(target);\n\n  if (targetType === 0\n  /* INVALID */\n  ) {\n    return target;\n  }\n\n  var proxy = new Proxy(target, targetType === 2\n  /* COLLECTION */\n  ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"\n    /* RAW */\n    ]);\n  }\n\n  return !!(value && value[\"__v_isReactive\"\n  /* IS_REACTIVE */\n  ]);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"\n  /* IS_READONLY */\n  ]);\n}\n\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"\n  /* IS_SHALLOW */\n  ]);\n}\n\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nfunction toRaw(observed) {\n  var raw = observed && observed[\"__v_raw\"\n  /* RAW */\n  ];\n  return raw ? toRaw(raw) : observed;\n}\n\nfunction markRaw(value) {\n  def(value, \"__v_skip\"\n  /* SKIP */\n  , true);\n  return value;\n}\n\nvar toReactive = function toReactive(value) {\n  return isObject(value) ? reactive(value) : value;\n};\n\nvar toReadonly = function toReadonly(value) {\n  return isObject(value) ? readonly(value) : value;\n};\n\nfunction trackRefValue(ref) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref);\n\n    if (process.env.NODE_ENV !== 'production') {\n      trackEffects(ref.dep || (ref.dep = createDep()), {\n        target: ref,\n        type: \"get\"\n        /* GET */\n        ,\n        key: 'value'\n      });\n    } else {\n      trackEffects(ref.dep || (ref.dep = createDep()));\n    }\n  }\n}\n\nfunction triggerRefValue(ref, newVal) {\n  ref = toRaw(ref);\n\n  if (ref.dep) {\n    if (process.env.NODE_ENV !== 'production') {\n      triggerEffects(ref.dep, {\n        target: ref,\n        type: \"set\"\n        /* SET */\n        ,\n        key: 'value',\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(ref.dep);\n    }\n  }\n}\n\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\n\nfunction ref(value) {\n  return createRef(value, false);\n}\n\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\n\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n\n  return new RefImpl(rawValue, shallow);\n}\n\nvar RefImpl = /*#__PURE__*/function () {\n  function RefImpl(value, __v_isShallow) {\n    _classCallCheck(this, RefImpl);\n\n    this.__v_isShallow = __v_isShallow;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n\n  _createClass(RefImpl, [{\n    key: \"value\",\n    get: function get() {\n      trackRefValue(this);\n      return this._value;\n    },\n    set: function set(newVal) {\n      newVal = this.__v_isShallow ? newVal : toRaw(newVal);\n\n      if (hasChanged(newVal, this._rawValue)) {\n        this._rawValue = newVal;\n        this._value = this.__v_isShallow ? newVal : toReactive(newVal);\n        triggerRefValue(this, newVal);\n      }\n    }\n  }]);\n\n  return RefImpl;\n}();\n\nfunction triggerRef(ref) {\n  triggerRefValue(ref, process.env.NODE_ENV !== 'production' ? ref.value : void 0);\n}\n\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nvar shallowUnwrapHandlers = {\n  get: function get(target, key, receiver) {\n    return unref(Reflect.get(target, key, receiver));\n  },\n  set: function set(target, key, value, receiver) {\n    var oldValue = target[key];\n\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\n\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\nvar CustomRefImpl = /*#__PURE__*/function () {\n  function CustomRefImpl(factory) {\n    var _this = this;\n\n    _classCallCheck(this, CustomRefImpl);\n\n    this.dep = undefined;\n    this.__v_isRef = true;\n\n    var _factory = factory(function () {\n      return trackRefValue(_this);\n    }, function () {\n      return triggerRefValue(_this);\n    }),\n        get = _factory.get,\n        set = _factory.set;\n\n    this._get = get;\n    this._set = set;\n  }\n\n  _createClass(CustomRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      return this._get();\n    },\n    set: function set(newVal) {\n      this._set(newVal);\n    }\n  }]);\n\n  return CustomRefImpl;\n}();\n\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\n\nfunction toRefs(object) {\n  if (process.env.NODE_ENV !== 'production' && !isProxy(object)) {\n    console.warn(\"toRefs() expects a reactive object but received a plain one.\");\n  }\n\n  var ret = isArray(object) ? new Array(object.length) : {};\n\n  for (var key in object) {\n    ret[key] = toRef(object, key);\n  }\n\n  return ret;\n}\n\nvar ObjectRefImpl = /*#__PURE__*/function () {\n  function ObjectRefImpl(_object, _key, _defaultValue) {\n    _classCallCheck(this, ObjectRefImpl);\n\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n\n  _createClass(ObjectRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      var val = this._object[this._key];\n      return val === undefined ? this._defaultValue : val;\n    },\n    set: function set(newVal) {\n      this._object[this._key] = newVal;\n    }\n  }]);\n\n  return ObjectRefImpl;\n}();\n\nfunction toRef(object, key, defaultValue) {\n  var val = object[key];\n  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);\n}\n\nvar ComputedRefImpl = /*#__PURE__*/function () {\n  function ComputedRefImpl(getter, _setter, isReadonly, isSSR) {\n    var _this2 = this;\n\n    _classCallCheck(this, ComputedRefImpl);\n\n    this._setter = _setter;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, function () {\n      if (!_this2._dirty) {\n        _this2._dirty = true;\n        triggerRefValue(_this2);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"\n    /* IS_READONLY */\n    ] = isReadonly;\n  }\n\n  _createClass(ComputedRefImpl, [{\n    key: \"value\",\n    get: function get() {\n      // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n      var self = toRaw(this);\n      trackRefValue(self);\n\n      if (self._dirty || !self._cacheable) {\n        self._dirty = false;\n        self._value = self.effect.run();\n      }\n\n      return self._value;\n    },\n    set: function set(newValue) {\n      this._setter(newValue);\n    }\n  }]);\n\n  return ComputedRefImpl;\n}();\n\nfunction computed(getterOrOptions, debugOptions) {\n  var isSSR = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var getter;\n  var setter;\n  var onlyGetter = isFunction(getterOrOptions);\n\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = process.env.NODE_ENV !== 'production' ? function () {\n      console.warn('Write operation failed: computed value is readonly');\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  var cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n\n  if (process.env.NODE_ENV !== 'production' && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n\n  return cRef;\n}\n\nvar _a;\n\nvar tick = /*#__PURE__*/Promise.resolve();\nvar queue = [];\nvar queued = false;\n\nvar scheduler = function scheduler(fn) {\n  queue.push(fn);\n\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\n\nvar flush = function flush() {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n\n  queue.length = 0;\n  queued = false;\n};\n\nvar DeferredComputedRefImpl = /*#__PURE__*/function () {\n  function DeferredComputedRefImpl(getter) {\n    var _this3 = this;\n\n    _classCallCheck(this, DeferredComputedRefImpl);\n\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[_a] = true;\n    var compareTarget;\n    var hasCompareTarget = false;\n    var scheduled = false;\n    this.effect = new ReactiveEffect(getter, function (computedTrigger) {\n      if (_this3.dep) {\n        if (computedTrigger) {\n          compareTarget = _this3._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          var valueToCompare = hasCompareTarget ? compareTarget : _this3._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(function () {\n            if (_this3.effect.active && _this3._get() !== valueToCompare) {\n              triggerRefValue(_this3);\n            }\n\n            scheduled = false;\n          });\n        } // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n\n\n        var _iterator3 = _createForOfIteratorHelper(_this3.dep),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var e = _step3.value;\n\n            if (e.computed instanceof DeferredComputedRefImpl) {\n              e.scheduler(true\n              /* computedTrigger */\n              );\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      _this3._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n\n  _createClass(DeferredComputedRefImpl, [{\n    key: \"_get\",\n    value: function _get() {\n      if (this._dirty) {\n        this._dirty = false;\n        return this._value = this.effect.run();\n      }\n\n      return this._value;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      trackRefValue(this); // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n\n      return toRaw(this)._get();\n    }\n  }]);\n\n  return DeferredComputedRefImpl;\n}();\n\n_a = \"__v_isReadonly\"\n/* IS_READONLY */\n;\n\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };","map":{"version":3,"sources":["C:/Users/Max/Desktop/project1.0.0-main/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"names":["extend","isArray","isMap","isIntegerKey","hasOwn","isSymbol","isObject","hasChanged","makeMap","capitalize","toRawType","def","isFunction","NOOP","warn","msg","args","console","activeEffectScope","EffectScope","detached","active","effects","cleanups","parent","index","scopes","push","fn","currentEffectScope","process","env","NODE_ENV","fromParent","i","l","length","stop","last","pop","effectScope","recordEffectScope","effect","scope","getCurrentScope","onScopeDispose","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","initDepMarkers","deps","finalizeDepMarkers","ptr","delete","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","undefined","lastShouldTrack","shouldTrack","cleanupEffect","deferStop","onStop","options","_effect","lazy","run","runner","bind","trackStack","pauseTracking","enableTracking","resetTracking","track","target","type","key","depsMap","get","set","Map","eventInfo","trackEffects","debuggerEventExtraInfo","has","add","onTrack","Object","assign","trigger","newValue","oldValue","oldTarget","values","forEach","triggerEffects","allowRecurse","onTrigger","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","map","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","arr","toRaw","res","apply","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","isRef","shouldUnwrap","value","readonly","reactive","createSetter","shallowSet","isShallow","hadKey","Number","result","deleteProperty","ownKeys","mutableHandlers","readonlyHandlers","String","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","get$1","rawTarget","rawKey","wrap","toReadonly","toReactive","call","has$1","size","proto","set$1","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","iteratorMethods","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","trackRefValue","ref","triggerRefValue","newVal","r","__v_isRef","createRef","shallowRef","rawValue","RefImpl","__v_isShallow","_rawValue","_value","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","object","ret","Array","toRef","ObjectRefImpl","_object","_key","_defaultValue","val","defaultValue","ComputedRefImpl","getter","_setter","isSSR","_dirty","computed","_cacheable","self","getterOrOptions","debugOptions","setter","onlyGetter","cRef","_a","tick","Promise","resolve","queue","queued","then","flush","DeferredComputedRefImpl","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","e","deferredComputed"],"mappings":"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","sourcesContent":["import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n    console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n    constructor(detached = false) {\n        /**\n         * @internal\n         */\n        this.active = true;\n        /**\n         * @internal\n         */\n        this.effects = [];\n        /**\n         * @internal\n         */\n        this.cleanups = [];\n        if (!detached && activeEffectScope) {\n            this.parent = activeEffectScope;\n            this.index =\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n        }\n    }\n    run(fn) {\n        if (this.active) {\n            const currentEffectScope = activeEffectScope;\n            try {\n                activeEffectScope = this;\n                return fn();\n            }\n            finally {\n                activeEffectScope = currentEffectScope;\n            }\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            warn(`cannot run an inactive effect scope.`);\n        }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    on() {\n        activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    off() {\n        activeEffectScope = this.parent;\n    }\n    stop(fromParent) {\n        if (this.active) {\n            let i, l;\n            for (i = 0, l = this.effects.length; i < l; i++) {\n                this.effects[i].stop();\n            }\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\n                this.cleanups[i]();\n            }\n            if (this.scopes) {\n                for (i = 0, l = this.scopes.length; i < l; i++) {\n                    this.scopes[i].stop(true);\n                }\n            }\n            // nested scope, dereference from parent to avoid memory leaks\n            if (this.parent && !fromParent) {\n                // optimized O(1) removal\n                const last = this.parent.scopes.pop();\n                if (last && last !== this) {\n                    this.parent.scopes[this.index] = last;\n                    last.index = this.index;\n                }\n            }\n            this.active = false;\n        }\n    }\n}\nfunction effectScope(detached) {\n    return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n    if (scope && scope.active) {\n        scope.effects.push(effect);\n    }\n}\nfunction getCurrentScope() {\n    return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n    if (activeEffectScope) {\n        activeEffectScope.cleanups.push(fn);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        warn(`onScopeDispose() is called when there is no active effect scope` +\n            ` to be associated with.`);\n    }\n}\n\nconst createDep = (effects) => {\n    const dep = new Set(effects);\n    dep.w = 0;\n    dep.n = 0;\n    return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].w |= trackOpBit; // set was tracked\n        }\n    }\n};\nconst finalizeDepMarkers = (effect) => {\n    const { deps } = effect;\n    if (deps.length) {\n        let ptr = 0;\n        for (let i = 0; i < deps.length; i++) {\n            const dep = deps[i];\n            if (wasTracked(dep) && !newTracked(dep)) {\n                dep.delete(effect);\n            }\n            else {\n                deps[ptr++] = dep;\n            }\n            // clear bits\n            dep.w &= ~trackOpBit;\n            dep.n &= ~trackOpBit;\n        }\n        deps.length = ptr;\n    }\n};\n\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\nclass ReactiveEffect {\n    constructor(fn, scheduler = null, scope) {\n        this.fn = fn;\n        this.scheduler = scheduler;\n        this.active = true;\n        this.deps = [];\n        this.parent = undefined;\n        recordEffectScope(this, scope);\n    }\n    run() {\n        if (!this.active) {\n            return this.fn();\n        }\n        let parent = activeEffect;\n        let lastShouldTrack = shouldTrack;\n        while (parent) {\n            if (parent === this) {\n                return;\n            }\n            parent = parent.parent;\n        }\n        try {\n            this.parent = activeEffect;\n            activeEffect = this;\n            shouldTrack = true;\n            trackOpBit = 1 << ++effectTrackDepth;\n            if (effectTrackDepth <= maxMarkerBits) {\n                initDepMarkers(this);\n            }\n            else {\n                cleanupEffect(this);\n            }\n            return this.fn();\n        }\n        finally {\n            if (effectTrackDepth <= maxMarkerBits) {\n                finalizeDepMarkers(this);\n            }\n            trackOpBit = 1 << --effectTrackDepth;\n            activeEffect = this.parent;\n            shouldTrack = lastShouldTrack;\n            this.parent = undefined;\n            if (this.deferStop) {\n                this.stop();\n            }\n        }\n    }\n    stop() {\n        // stopped while running itself - defer the cleanup\n        if (activeEffect === this) {\n            this.deferStop = true;\n        }\n        else if (this.active) {\n            cleanupEffect(this);\n            if (this.onStop) {\n                this.onStop();\n            }\n            this.active = false;\n        }\n    }\n}\nfunction cleanupEffect(effect) {\n    const { deps } = effect;\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].delete(effect);\n        }\n        deps.length = 0;\n    }\n}\nfunction effect(fn, options) {\n    if (fn.effect) {\n        fn = fn.effect.fn;\n    }\n    const _effect = new ReactiveEffect(fn);\n    if (options) {\n        extend(_effect, options);\n        if (options.scope)\n            recordEffectScope(_effect, options.scope);\n    }\n    if (!options || !options.lazy) {\n        _effect.run();\n    }\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner;\n}\nfunction stop(runner) {\n    runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n}\nfunction enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n}\nfunction resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = createDep()));\n        }\n        const eventInfo = (process.env.NODE_ENV !== 'production')\n            ? { effect: activeEffect, target, type, key }\n            : undefined;\n        trackEffects(dep, eventInfo);\n    }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n    let shouldTrack = false;\n    if (effectTrackDepth <= maxMarkerBits) {\n        if (!newTracked(dep)) {\n            dep.n |= trackOpBit; // set newly tracked\n            shouldTrack = !wasTracked(dep);\n        }\n    }\n    else {\n        // Full cleanup mode.\n        shouldTrack = !dep.has(activeEffect);\n    }\n    if (shouldTrack) {\n        dep.add(activeEffect);\n        activeEffect.deps.push(dep);\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.onTrack) {\n            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));\n        }\n    }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        // never been tracked\n        return;\n    }\n    let deps = [];\n    if (type === \"clear\" /* CLEAR */) {\n        // collection being cleared\n        // trigger all effects for target\n        deps = [...depsMap.values()];\n    }\n    else if (key === 'length' && isArray(target)) {\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || key >= newValue) {\n                deps.push(dep);\n            }\n        });\n    }\n    else {\n        // schedule runs for SET | ADD | DELETE\n        if (key !== void 0) {\n            deps.push(depsMap.get(key));\n        }\n        // also run for iteration key on ADD | DELETE | Map.SET\n        switch (type) {\n            case \"add\" /* ADD */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                else if (isIntegerKey(key)) {\n                    // new index added to array -> length changes\n                    deps.push(depsMap.get('length'));\n                }\n                break;\n            case \"delete\" /* DELETE */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                break;\n            case \"set\" /* SET */:\n                if (isMap(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                }\n                break;\n        }\n    }\n    const eventInfo = (process.env.NODE_ENV !== 'production')\n        ? { target, type, key, newValue, oldValue, oldTarget }\n        : undefined;\n    if (deps.length === 1) {\n        if (deps[0]) {\n            if ((process.env.NODE_ENV !== 'production')) {\n                triggerEffects(deps[0], eventInfo);\n            }\n            else {\n                triggerEffects(deps[0]);\n            }\n        }\n    }\n    else {\n        const effects = [];\n        for (const dep of deps) {\n            if (dep) {\n                effects.push(...dep);\n            }\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(createDep(effects), eventInfo);\n        }\n        else {\n            triggerEffects(createDep(effects));\n        }\n    }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n    // spread into array for stabilization\n    for (const effect of isArray(dep) ? dep : [...dep]) {\n        if (effect !== activeEffect || effect.allowRecurse) {\n            if ((process.env.NODE_ENV !== 'production') && effect.onTrigger) {\n                effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));\n            }\n            if (effect.scheduler) {\n                effect.scheduler();\n            }\n            else {\n                effect.run();\n            }\n        }\n    }\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n/*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n    .map(key => Symbol[key])\n    .filter(isSymbol));\nconst get = /*#__PURE__*/ createGetter();\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n    const instrumentations = {};\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            const arr = toRaw(this);\n            for (let i = 0, l = this.length; i < l; i++) {\n                track(arr, \"get\" /* GET */, i + '');\n            }\n            // we run the method using the original args first (which may be reactive)\n            const res = arr[key](...args);\n            if (res === -1 || res === false) {\n                // if that didn't work, run it again using raw values.\n                return arr[key](...args.map(toRaw));\n            }\n            else {\n                return res;\n            }\n        };\n    });\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            pauseTracking();\n            const res = toRaw(this)[key].apply(this, args);\n            resetTracking();\n            return res;\n        };\n    });\n    return instrumentations;\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_isShallow\" /* IS_SHALLOW */) {\n            return shallow;\n        }\n        else if (key === \"__v_raw\" /* RAW */ &&\n            receiver ===\n                (isReadonly\n                    ? shallow\n                        ? shallowReadonlyMap\n                        : readonlyMap\n                    : shallow\n                        ? shallowReactiveMap\n                        : reactiveMap).get(target)) {\n            return target;\n        }\n        const targetIsArray = isArray(target);\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n            return Reflect.get(arrayInstrumentations, key, receiver);\n        }\n        const res = Reflect.get(target, key, receiver);\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n            return res;\n        }\n        if (!isReadonly) {\n            track(target, \"get\" /* GET */, key);\n        }\n        if (shallow) {\n            return res;\n        }\n        if (isRef(res)) {\n            // ref unwrapping - does not apply for Array + integer key.\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n            return shouldUnwrap ? res.value : res;\n        }\n        if (isObject(res)) {\n            // Convert returned value into a proxy as well. we do the isObject check\n            // here to avoid invalid value warning. Also need to lazy access readonly\n            // and reactive here to avoid circular dependency.\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n        return res;\n    };\n}\nconst set = /*#__PURE__*/ createSetter();\nconst shallowSet = /*#__PURE__*/ createSetter(true);\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        let oldValue = target[key];\n        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n            return false;\n        }\n        if (!shallow && !isReadonly(value)) {\n            if (!isShallow(value)) {\n                value = toRaw(value);\n                oldValue = toRaw(oldValue);\n            }\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n                oldValue.value = value;\n                return true;\n            }\n        }\n        const hadKey = isArray(target) && isIntegerKey(key)\n            ? Number(key) < target.length\n            : hasOwn(target, key);\n        const result = Reflect.set(target, key, value, receiver);\n        // don't trigger if target is something up in the prototype chain of original\n        if (target === toRaw(receiver)) {\n            if (!hadKey) {\n                trigger(target, \"add\" /* ADD */, key, value);\n            }\n            else if (hasChanged(value, oldValue)) {\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\n            }\n        }\n        return result;\n    };\n}\nfunction deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n        track(target, \"has\" /* HAS */, key);\n    }\n    return result;\n}\nfunction ownKeys(target) {\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n    get,\n    set,\n    deleteProperty,\n    has,\n    ownKeys\n};\nconst readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n});\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\n    // of the value\n    target = target[\"__v_raw\" /* RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (key !== rawKey) {\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\n    }\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\n    const { has } = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n    }\n    else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n    }\n    else if (target !== rawTarget) {\n        // #3602 readonly(reactive(Map))\n        // ensure that the nested reactive `Map` can do tracking for itself\n        target.get(key);\n    }\n}\nfunction has$1(key, isReadonly = false) {\n    const target = this[\"__v_raw\" /* RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (key !== rawKey) {\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\n    }\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\n    return key === rawKey\n        ? target.has(key)\n        : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n    target = target[\"__v_raw\" /* RAW */];\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\n    return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\" /* ADD */, value, value);\n    }\n    return this;\n}\nfunction set$1(key, value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n        trigger(target, \"add\" /* ADD */, key, value);\n    }\n    else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\n    }\n    return this;\n}\nfunction deleteEntry(key) {\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get ? get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    const result = target.delete(key);\n    if (hadKey) {\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction clear() {\n    const target = toRaw(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = (process.env.NODE_ENV !== 'production')\n        ? isMap(target)\n            ? new Map(target)\n            : new Set(target)\n        : undefined;\n    // forward the operation before queueing reactions\n    const result = target.clear();\n    if (hadItems) {\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\n    }\n    return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n    return function forEach(callback, thisArg) {\n        const observed = this;\n        const target = observed[\"__v_raw\" /* RAW */];\n        const rawTarget = toRaw(target);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\n        return target.forEach((value, key) => {\n            // important: make sure the callback is\n            // 1. invoked with the reactive map as `this` and 3rd arg\n            // 2. the value received should be a corresponding reactive/readonly.\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\n        });\n    };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n    return function (...args) {\n        const target = this[\"__v_raw\" /* RAW */];\n        const rawTarget = toRaw(target);\n        const targetIsMap = isMap(rawTarget);\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\n        const isKeyOnly = method === 'keys' && targetIsMap;\n        const innerIterator = target[method](...args);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly &&\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n        // return a wrapped iterator which returns observed versions of the\n        // values emitted from the real iterator\n        return {\n            // iterator protocol\n            next() {\n                const { value, done } = innerIterator.next();\n                return done\n                    ? { value, done }\n                    : {\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n                        done\n                    };\n            },\n            // iterable protocol\n            [Symbol.iterator]() {\n                return this;\n            }\n        };\n    };\n}\nfunction createReadonlyMethod(type) {\n    return function (...args) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n        }\n        return type === \"delete\" /* DELETE */ ? false : this;\n    };\n}\nfunction createInstrumentations() {\n    const mutableInstrumentations = {\n        get(key) {\n            return get$1(this, key);\n        },\n        get size() {\n            return size(this);\n        },\n        has: has$1,\n        add,\n        set: set$1,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, false)\n    };\n    const shallowInstrumentations = {\n        get(key) {\n            return get$1(this, key, false, true);\n        },\n        get size() {\n            return size(this);\n        },\n        has: has$1,\n        add,\n        set: set$1,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, true)\n    };\n    const readonlyInstrumentations = {\n        get(key) {\n            return get$1(this, key, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has$1.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* ADD */),\n        set: createReadonlyMethod(\"set\" /* SET */),\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\n        forEach: createForEach(true, false)\n    };\n    const shallowReadonlyInstrumentations = {\n        get(key) {\n            return get$1(this, key, true, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has$1.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* ADD */),\n        set: createReadonlyMethod(\"set\" /* SET */),\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\n        forEach: createForEach(true, true)\n    };\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n    iteratorMethods.forEach(method => {\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n    });\n    return [\n        mutableInstrumentations,\n        readonlyInstrumentations,\n        shallowInstrumentations,\n        shallowReadonlyInstrumentations\n    ];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n    const instrumentations = shallow\n        ? isReadonly\n            ? shallowReadonlyInstrumentations\n            : shallowInstrumentations\n        : isReadonly\n            ? readonlyInstrumentations\n            : mutableInstrumentations;\n    return (target, key, receiver) => {\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_raw\" /* RAW */) {\n            return target;\n        }\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\n            ? instrumentations\n            : target, key, receiver);\n    };\n}\nconst mutableCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n    const rawKey = toRaw(key);\n    if (rawKey !== key && has.call(target, rawKey)) {\n        const type = toRawType(target);\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n            `which can lead to inconsistencies. ` +\n            `Avoid differentiating between the raw and reactive versions ` +\n            `of an object and only use the reactive version if possible.`);\n    }\n}\n\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return 1 /* COMMON */;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return 2 /* COLLECTION */;\n        default:\n            return 0 /* INVALID */;\n    }\n}\nfunction getTargetType(value) {\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\n        ? 0 /* INVALID */\n        : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (isReadonly(target)) {\n        return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    if (!isObject(target)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(`value cannot be made reactive: ${String(target)}`);\n        }\n        return target;\n    }\n    // target is already a Proxy, return it.\n    // exception: calling readonly() on a reactive object\n    if (target[\"__v_raw\" /* RAW */] &&\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\n        return target;\n    }\n    // target already has corresponding Proxy\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n        return existingProxy;\n    }\n    // only a whitelist of value types can be observed.\n    const targetType = getTargetType(target);\n    if (targetType === 0 /* INVALID */) {\n        return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n}\nfunction isReactive(value) {\n    if (isReadonly(value)) {\n        return isReactive(value[\"__v_raw\" /* RAW */]);\n    }\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\n}\nfunction isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\n}\nfunction isShallow(value) {\n    return !!(value && value[\"__v_isShallow\" /* IS_SHALLOW */]);\n}\nfunction isProxy(value) {\n    return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* RAW */];\n    return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n    def(value, \"__v_skip\" /* SKIP */, true);\n    return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n        if ((process.env.NODE_ENV !== 'production')) {\n            trackEffects(ref.dep || (ref.dep = createDep()), {\n                target: ref,\n                type: \"get\" /* GET */,\n                key: 'value'\n            });\n        }\n        else {\n            trackEffects(ref.dep || (ref.dep = createDep()));\n        }\n    }\n}\nfunction triggerRefValue(ref, newVal) {\n    ref = toRaw(ref);\n    if (ref.dep) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(ref.dep, {\n                target: ref,\n                type: \"set\" /* SET */,\n                key: 'value',\n                newValue: newVal\n            });\n        }\n        else {\n            triggerEffects(ref.dep);\n        }\n    }\n}\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n    return createRef(value, false);\n}\nfunction shallowRef(value) {\n    return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n        this.__v_isShallow = __v_isShallow;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n    get value() {\n        trackRefValue(this);\n        return this._value;\n    }\n    set value(newVal) {\n        newVal = this.__v_isShallow ? newVal : toRaw(newVal);\n        if (hasChanged(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n            this._value = this.__v_isShallow ? newVal : toReactive(newVal);\n            triggerRefValue(this, newVal);\n        }\n    }\n}\nfunction triggerRef(ref) {\n    triggerRefValue(ref, (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\n}\nfunction unref(ref) {\n    return isRef(ref) ? ref.value : ref;\n}\nconst shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n        const oldValue = target[key];\n        if (isRef(oldValue) && !isRef(value)) {\n            oldValue.value = value;\n            return true;\n        }\n        else {\n            return Reflect.set(target, key, value, receiver);\n        }\n    }\n};\nfunction proxyRefs(objectWithRefs) {\n    return isReactive(objectWithRefs)\n        ? objectWithRefs\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n    constructor(factory) {\n        this.dep = undefined;\n        this.__v_isRef = true;\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n        this._get = get;\n        this._set = set;\n    }\n    get value() {\n        return this._get();\n    }\n    set value(newVal) {\n        this._set(newVal);\n    }\n}\nfunction customRef(factory) {\n    return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n        ret[key] = toRef(object, key);\n    }\n    return ret;\n}\nclass ObjectRefImpl {\n    constructor(_object, _key, _defaultValue) {\n        this._object = _object;\n        this._key = _key;\n        this._defaultValue = _defaultValue;\n        this.__v_isRef = true;\n    }\n    get value() {\n        const val = this._object[this._key];\n        return val === undefined ? this._defaultValue : val;\n    }\n    set value(newVal) {\n        this._object[this._key] = newVal;\n    }\n}\nfunction toRef(object, key, defaultValue) {\n    const val = object[key];\n    return isRef(val)\n        ? val\n        : new ObjectRefImpl(object, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        this._setter = _setter;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this._dirty = true;\n        this.effect = new ReactiveEffect(getter, () => {\n            if (!this._dirty) {\n                this._dirty = true;\n                triggerRefValue(this);\n            }\n        });\n        this.effect.computed = this;\n        this.effect.active = this._cacheable = !isSSR;\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\n    }\n    get value() {\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        const self = toRaw(this);\n        trackRefValue(self);\n        if (self._dirty || !self._cacheable) {\n            self._dirty = false;\n            self._value = self.effect.run();\n        }\n        return self._value;\n    }\n    set value(newValue) {\n        this._setter(newValue);\n    }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    const onlyGetter = isFunction(getterOrOptions);\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = (process.env.NODE_ENV !== 'production')\n            ? () => {\n                console.warn('Write operation failed: computed value is readonly');\n            }\n            : NOOP;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n    if ((process.env.NODE_ENV !== 'production') && debugOptions && !isSSR) {\n        cRef.effect.onTrack = debugOptions.onTrack;\n        cRef.effect.onTrigger = debugOptions.onTrigger;\n    }\n    return cRef;\n}\n\nvar _a;\nconst tick = /*#__PURE__*/ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n    queue.push(fn);\n    if (!queued) {\n        queued = true;\n        tick.then(flush);\n    }\n};\nconst flush = () => {\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]();\n    }\n    queue.length = 0;\n    queued = false;\n};\nclass DeferredComputedRefImpl {\n    constructor(getter) {\n        this.dep = undefined;\n        this._dirty = true;\n        this.__v_isRef = true;\n        this[_a] = true;\n        let compareTarget;\n        let hasCompareTarget = false;\n        let scheduled = false;\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n            if (this.dep) {\n                if (computedTrigger) {\n                    compareTarget = this._value;\n                    hasCompareTarget = true;\n                }\n                else if (!scheduled) {\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n                    scheduled = true;\n                    hasCompareTarget = false;\n                    scheduler(() => {\n                        if (this.effect.active && this._get() !== valueToCompare) {\n                            triggerRefValue(this);\n                        }\n                        scheduled = false;\n                    });\n                }\n                // chained upstream computeds are notified synchronously to ensure\n                // value invalidation in case of sync access; normal effects are\n                // deferred to be triggered in scheduler.\n                for (const e of this.dep) {\n                    if (e.computed instanceof DeferredComputedRefImpl) {\n                        e.scheduler(true /* computedTrigger */);\n                    }\n                }\n            }\n            this._dirty = true;\n        });\n        this.effect.computed = this;\n    }\n    _get() {\n        if (this._dirty) {\n            this._dirty = false;\n            return (this._value = this.effect.run());\n        }\n        return this._value;\n    }\n    get value() {\n        trackRefValue(this);\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        return toRaw(this)._get();\n    }\n}\n_a = \"__v_isReadonly\" /* IS_READONLY */;\nfunction deferredComputed(getter) {\n    return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n"]},"metadata":{},"sourceType":"module"}