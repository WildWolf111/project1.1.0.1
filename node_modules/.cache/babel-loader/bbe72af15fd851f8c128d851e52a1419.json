{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Projects/success/project_v.1.0.0/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"C:/Projects/success/project_v.1.0.0/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport { createWebHistory, createRouter } from \"vue-router\";\nimport store from '@/state/store';\nimport routes from './routes';\nimport appConfig from \"../../app.config\";\nvar router = createRouter({\n  history: createWebHistory(),\n  routes: routes,\n  // Use the HTML5 history API (i.e. normal-looking routes)\n  // instead of routes with hashes (e.g. example.com/#/about).\n  // This may require some server configuration in production:\n  // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n  mode: 'history',\n  // Simulate native-like scroll behavior when navigating to a new\n  // route and using back/forward buttons.\n  scrollBehavior: function scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition;\n    } else {\n      return {\n        top: 0,\n        left: 0\n      };\n    }\n  }\n}); // Before each route evaluates...\n\nrouter.beforeEach(function (routeTo, routeFrom, next) {\n  if (process.env.VUE_APP_DEFAULT_AUTH === \"firebase\") {\n    // Check if auth is required on this route\n    // (including nested routes).\n    var authRequired = routeTo.matched.some(function (route) {\n      return route.meta.authRequired;\n    }); // If auth isn't required for the route, just continue.\n\n    if (!authRequired) return next(); // If auth is required and the user is logged in...\n\n    if (store.getters['auth/loggedIn']) {\n      // Validate the local user token...\n      return store.dispatch('auth/validate').then(function (validUser) {\n        // Then continue if the token still represents a valid user,\n        // otherwise redirect to login.\n        validUser ? next() : redirectToLogin();\n      });\n    } // If auth is required and the user is NOT currently logged in,\n    // redirect to login.\n\n\n    redirectToLogin(); // eslint-disable-next-line no-unused-vars\n    // eslint-disable-next-line no-inner-declarations\n\n    function redirectToLogin() {\n      // Pass the original route to the login component\n      next({\n        name: 'login',\n        query: {\n          redirectFrom: routeTo.fullPath\n        }\n      });\n    }\n  } else {\n    var publicPages = ['/login', '/register', '/forgot-password'];\n    var authpage = !publicPages.includes(routeTo.path);\n    var loggeduser = localStorage.getItem('user');\n    console.log(localStorage.getItem('user'));\n\n    if (authpage && !loggeduser) {\n      return next('/login');\n    }\n\n    next();\n  }\n});\nrouter.beforeResolve( /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(routeTo, routeFrom, next) {\n    var _iterator, _step, _loop;\n\n    return regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            // For each matched route...\n            _iterator = _createForOfIteratorHelper(routeTo.matched);\n            _context2.prev = 2;\n            _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop() {\n              var route;\n              return regeneratorRuntime.wrap(function _loop$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      route = _step.value;\n                      _context.next = 3;\n                      return new Promise(function (resolve, reject) {\n                        // If a `beforeResolve` hook is defined, call it with\n                        // the same arguments as the `beforeEnter` hook.\n                        if (route.meta && route.meta.beforeResolve) {\n                          route.meta.beforeResolve(routeTo, routeFrom, function () {\n                            // If the user chose to redirect...\n                            if (arguments.length) {\n                              // If redirecting to the same route we're coming from...\n                              // Complete the redirect.\n                              next.apply(void 0, arguments);\n                              reject(new Error('Redirected'));\n                            } else {\n                              resolve();\n                            }\n                          });\n                        } else {\n                          // Otherwise, continue resolving the route.\n                          resolve();\n                        }\n                      });\n\n                    case 3:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _loop);\n            });\n\n            _iterator.s();\n\n          case 5:\n            if ((_step = _iterator.n()).done) {\n              _context2.next = 9;\n              break;\n            }\n\n            return _context2.delegateYield(_loop(), \"t0\", 7);\n\n          case 7:\n            _context2.next = 5;\n            break;\n\n          case 9:\n            _context2.next = 14;\n            break;\n\n          case 11:\n            _context2.prev = 11;\n            _context2.t1 = _context2[\"catch\"](2);\n\n            _iterator.e(_context2.t1);\n\n          case 14:\n            _context2.prev = 14;\n\n            _iterator.f();\n\n            return _context2.finish(14);\n\n          case 17:\n            _context2.next = 22;\n            break;\n\n          case 19:\n            _context2.prev = 19;\n            _context2.t2 = _context2[\"catch\"](0);\n            return _context2.abrupt(\"return\");\n\n          case 22:\n            document.title = routeTo.meta.title + ' | ' + appConfig.title; // If we reach this point, continue resolving the route.\n\n            next();\n\n          case 24:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, null, [[0, 19], [2, 11, 14, 17]]);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}());\nexport default router;","map":{"version":3,"sources":["C:/Projects/success/project_v.1.0.0/src/router/index.js"],"names":["createWebHistory","createRouter","store","routes","appConfig","router","history","mode","scrollBehavior","to","from","savedPosition","top","left","beforeEach","routeTo","routeFrom","next","process","env","VUE_APP_DEFAULT_AUTH","authRequired","matched","some","route","meta","getters","dispatch","then","validUser","redirectToLogin","name","query","redirectFrom","fullPath","publicPages","authpage","includes","path","loggeduser","localStorage","getItem","console","log","beforeResolve","Promise","resolve","reject","length","Error","document","title"],"mappings":"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","sourcesContent":["import { createWebHistory, createRouter } from \"vue-router\";\n\nimport store from '@/state/store'\nimport routes from './routes'\nimport appConfig from \"../../app.config\";\n\nconst router = createRouter({\n    history: createWebHistory(),\n    routes,\n    // Use the HTML5 history API (i.e. normal-looking routes)\n    // instead of routes with hashes (e.g. example.com/#/about).\n    // This may require some server configuration in production:\n    // https://router.vuejs.org/en/essentials/history-mode.html#example-server-configurations\n    mode: 'history',\n    // Simulate native-like scroll behavior when navigating to a new\n    // route and using back/forward buttons.\n    scrollBehavior(to, from, savedPosition) {\n        if (savedPosition) {\n            return savedPosition\n        } else {\n            return { top: 0, left: 0 }\n        }\n    },\n})\n\n// Before each route evaluates...\nrouter.beforeEach((routeTo, routeFrom, next) => {\n    if (process.env.VUE_APP_DEFAULT_AUTH === \"firebase\") {\n        // Check if auth is required on this route\n        // (including nested routes).\n        const authRequired = routeTo.matched.some((route) => route.meta.authRequired)\n\n        // If auth isn't required for the route, just continue.\n        if (!authRequired) return next()\n\n        // If auth is required and the user is logged in...\n        if (store.getters['auth/loggedIn']) {\n            // Validate the local user token...\n            return store.dispatch('auth/validate').then((validUser) => {\n                // Then continue if the token still represents a valid user,\n                // otherwise redirect to login.\n                validUser ? next() : redirectToLogin()\n            })\n        }\n\n        // If auth is required and the user is NOT currently logged in,\n        // redirect to login.\n        redirectToLogin()\n\n        // eslint-disable-next-line no-unused-vars\n        // eslint-disable-next-line no-inner-declarations\n        function redirectToLogin() {\n            // Pass the original route to the login component\n            next({ name: 'login', query: { redirectFrom: routeTo.fullPath } })\n        }\n    } else {\n        const publicPages = ['/login', '/register', '/forgot-password'];\n        const authpage = !publicPages.includes(routeTo.path);\n        const loggeduser = localStorage.getItem('user');\n        console.log(localStorage.getItem('user'))\n        if (authpage && !loggeduser) {\n            return next('/login');\n        }\n\n        next();\n    }\n})\n\nrouter.beforeResolve(async(routeTo, routeFrom, next) => {\n    // Create a `beforeResolve` hook, which fires whenever\n    // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n    // allows us to ensure data is fetched even when params change,\n    // but the resolved route does not. We put it in `meta` to\n    // indicate that it's a hook we created, rather than part of\n    // Vue Router (yet?).\n    try {\n        // For each matched route...\n        for (const route of routeTo.matched) {\n            await new Promise((resolve, reject) => {\n                // If a `beforeResolve` hook is defined, call it with\n                // the same arguments as the `beforeEnter` hook.\n                if (route.meta && route.meta.beforeResolve) {\n                    route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n                        // If the user chose to redirect...\n                        if (args.length) {\n                            // If redirecting to the same route we're coming from...\n                            // Complete the redirect.\n                            next(...args)\n                            reject(new Error('Redirected'))\n                        } else {\n                            resolve()\n                        }\n                    })\n                } else {\n                    // Otherwise, continue resolving the route.\n                    resolve()\n                }\n            })\n        }\n        // If a `beforeResolve` hook chose to redirect, just return.\n    } catch (error) {\n        return\n    }\n    document.title = routeTo.meta.title + ' | ' + appConfig.title;\n    // If we reach this point, continue resolving the route.\n    next()\n})\n\nexport default router"]},"metadata":{},"sourceType":"module"}